---
title: "Calcul des profils de cyclistes et cartographie de leur localisation dans la ville"
author: "[Maëlle Lucas](https://perso.univ-rennes2.fr/maelle.lucas) et [Florent Demoraes](https://perso.univ-rennes2.fr/florent.demoraes)"
date: "18/11/2022"
output:
  word_document:
    toc: yes
    number_sections: true
  html_document:
    toc: yes
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = 'F:/Protocoles/Master 2/ASDT/2022-2023/2 - Analyses factorielles et classification/AFDM')
```

# Calcul des profils de cyclistes à l'aide d'une AFDM couplée à une CAH
## Chargement des packages nécessaires
```{r loading package, warning=FALSE, message = FALSE, error=FALSE}
library(FactoMineR)# Pour executer des analyses factorielles (telle que l'AFDM) et des classification (type CAH)
library(openxlsx) # Pour importer/exporter depuis/vers Excel
library(tidyverse) # on l'utilise ici pour notamment extraire des chaînes de caractère dans une colonne
library(sf) # pour manipuler les objets ayant une composante spatiale
library(spatstat) # pour le lissage spatial
library(sp) # pour utiliser la fonction as.owin de spatstat
library(maptools) # pour utiliser la fonction as.owin de spatstat
library(cartography) # pour la représentation carto et l'habillage des cartes
library(raster) # pour le traitement de données matricielles
library(factoextra) # pour améliorer le rendu des graphiques
```

## Import données en entrée (fichier Excel)
```{r Import donnees}
VariablesTypoProfilCyclistes <- read.xlsx("VariablesTypoProfilCyclistes.xlsx", sheet = "CyclistesImportSansNA_Dist_v2")
rownames(VariablesTypoProfilCyclistes) <- VariablesTypoProfilCyclistes$id_hog_pers # pour ajouter l'id des personnes comme entête de ligne
VariablesTypoProfilCyclistes$id_hog_pers <- NULL # pour supprimer la colonne
head(VariablesTypoProfilCyclistes)
str(VariablesTypoProfilCyclistes)
summary(VariablesTypoProfilCyclistes)
```

## Calcul de l'AFDM (Analyse Factorielle des Données Mixtes) pour déterminer des profils de cyclistes
```{r premiere AFDM, warning=FALSE, message = FALSE, error=FALSE, fig.height=15, fig.width=15}
res <- FAMD(VariablesTypoProfilCyclistes)
```

## Suppression des variables qui sont proches de l'origine du plan factoriel (peu discriminantes)
```{r suppression variables proche origine}
VariablesTypoProfilCyclistes$Experi <- NULL
VariablesTypoProfilCyclistes$NumMoto <- NULL
VariablesTypoProfilCyclistes$NumViajDia <- NULL
VariablesTypoProfilCyclistes$PartModInd <- NULL
```

## Affichage de la liste des variables restantes
```{r affichage liste variables}
print(as.data.frame(colnames(VariablesTypoProfilCyclistes)))
```

## filtrage des durées
```{r filtrage donnees, warning=FALSE, message = FALSE, error=FALSE, fig.height=15, fig.width=15}
VariablesTypoProfilCyclistes <- filter(VariablesTypoProfilCyclistes, Duracion < 300)
```

## Deuxième calcul de l'AFDM après suppression des variables peu discriminantes et le passage de certaines variables en illustratif
```{r deuxieme AFDM, warning=FALSE, message = FALSE, error=FALSE, fig.height=15, fig.width=15}
res <- FAMD(VariablesTypoProfilCyclistes, sup.var = c(2,6,9,10,11,15,17))
```

## Lancement de la CAH sur les résultats de l'AFDM
```{r lancement CAH, , warning=FALSE, message = FALSE, error=FALSE, fig.height=15, fig.width=15}
nbclasses <- 6 # tester avec différents nombres de classes
res.hcpc <- HCPC(res, kk=Inf, nb.clust=nbclasses, consol=FALSE, graph = FALSE) # kk=inf signifie pas de partition préalable, consol=FALSE signifie qu'on n'applique pas à l'issue de la CAH une consolidation (par les k-means)
plot(res.hcpc, choice="tree")
fviz_cluster(res.hcpc,
             repel = TRUE,            # Avoid label overlapping
             show.clust.cent = TRUE, # Show cluster centers
             palette = "jco",         # Color palette see ?ggpubr::ggpar
             ggtheme = theme_minimal(),
             main = "Factor map"
)
```

## Calcul du tableau avec effectifs par classe et du diagramme en barres associé
```{r calcul tableau effectifs}
dataclust <- as.data.frame(res.hcpc[["data.clust"]])
IndividusClasse <- aggregate(NivEducCL ~ clust, dataclust, length) # pour créer un tableau avec le nombre d'individus par classe
print(IndividusClasse)
barplot(IndividusClasse$NivEducCL, names = IndividusClasse$clust, main = "Distribution des individus par profil")
```


## Identifier les variables catégorielles qui ne prennent que deux modalités
```{r gestion des variables categorielles avec deux modalites}
# Cette opération est nécessaire pour simplifier ensuite les graphiques
TableauVariablesCategorielles <- Filter(is.character, VariablesTypoProfilCyclistes)

NbModalitesParVariable <- data.frame()

for (i in colnames(TableauVariablesCategorielles)){

  # Recuperation du nombre de modalités pour chaque variable catégorielle
  fichier<- length(unique(TableauVariablesCategorielles[[i]]))
  NbModalitesParVariable <- rbind(NbModalitesParVariable, fichier)
  
}

NbModalitesParVariable$Variable <- colnames(TableauVariablesCategorielles)

VariablesDeuxModalites <- NbModalitesParVariable[which(NbModalitesParVariable[,1] == 2),]
VariablesDeuxModalites <- as.character(VariablesDeuxModalites$Variable)
```

## Déterminer le seuil de la valeur v.test à retenir pour garder les variables qui décriront les classes 
```{r definition seuil significativite}
# Par défaut v.test > |1.96| - Dans le cas présent relever le seuil permet de filtrer le nombre de variables qui décriront les classes. On ne garde que celles qui sont ultra significatives
Seuil.v.test <- 3.29 # on accepte de se tromper une fois sur 1000
# en savoir plus https://www.medcalc.org/manual/values-of-the-normal-distribution.php
```

## Création des tableaux decrivant les profils par les variables quanti et quali et affichage des diagrammes
```{r filtrage variables deux modalites, fig.height=13}
# Pour les variables n'ayant que deux modalités, on n'en garde qu'une
for (i in 1:nbclasses){

  # Récuperation dans des tableaux de la description de chacune des N classes par les variables quanti
  b <- as.data.frame(res.hcpc$desc.var$quanti[[i]])
  b <- b[which(colnames(b) == 'v.test')]
  b <- signif(b,3) # pour arrondir les valeurs

  # Récuperation dans des tableaux de la description de chacune des N classes par les variables quali
  c <- as.data.frame(res.hcpc$desc.var$category[[i]])
  d <- as.data.frame(c$label <- rownames(c))
  d <- as.data.frame(c$label <- sub("\\=.*", "", c$label))
  d <- as.data.frame(c[which(c$label %in% VariablesDeuxModalites), ])
  d <- as.data.frame(d[which(d$v.test > 0),])
  e <- as.data.frame(c[which(!c$label %in% VariablesDeuxModalites), ])
  f <- as.data.frame(rbind(d, e))
  g <- as.data.frame(f$label <- NULL)
  c <- signif(f,3) # pour arrondir les valeurs
  c <- c[which(colnames(c) == 'v.test')]

  # Assemblage des tableaux avec les variables quanti et quali
  h <- as.data.frame(rbind(b,c))
  h <- as.data.frame(cbind(h, h$label <- row.names(h)))
  colnames(h) <- c("v.test", "label")
  h <- as.data.frame(h[order(h$v.test, decreasing = TRUE), ])
  h <- as.data.frame(h[which(!h$v.test == "Inf"),])
  h <- as.data.frame(h[which(abs(h$v.test) >= Seuil.v.test),])

  # pour tracer les diagrammes en barres horizontaux
  op <- par(oma=c(0,7,0,0))
  barplot((h$v.test), names = row.names(h), border = "white", horiz = TRUE, las = 1, xlim = c(-5 - max(abs(h$v.test)), 5 + max(abs(h$v.test))), cex.names=0.8, main = paste("profil",i, sep=""))
  par(op)
  
}
```

## Récupérer la colonne clust de la typologie pour chaque individu (dans le tableau initial) ainsi que l'id des personnes
```{r ajout colonne clust dans tableau initial}
VariablesTypoProfilCyclistes$profil <- dataclust$clust
VariablesTypoProfilCyclistes$id_hog_pers <- row.names(dataclust)
```

## Extraire l'id des ménages (id_hog) à partir la colonne id_hog_pers 
```{r ajout colonne id des menages dans tableau initial}
# utile par la suite pour récupérer les coord. XY du lieu de résidence du ménage
df <- data.frame(x = VariablesTypoProfilCyclistes$id_hog_pers)
df <- df %>% separate(x, c("id_hog", "id_pers"))
VariablesTypoProfilCyclistes$id_hog <- df$id_hog
```

## Exporter le tableau au format excel
```{r export}
write.xlsx(VariablesTypoProfilCyclistes, "VariablesTypoProfilCyclistesFINAL.xlsx")
browseURL("VariablesTypoProfilCyclistesFINAL.xlsx")
```

# Cartographie de la localisation des profils de cyclistes suivant leurs lieux de résidence et de destinations

## Carte des lieux de résidences des cyclistes suivant leur profil

### import des coordonnées XY du lieu de résidence des ménages comptant au moins un cycliste
```{r import fichier excel coord XY mza residence}
CoordXY_Hogar <- read.xlsx("CoordXY_Hogar_Alea.xlsx")
```

### jointure des coordonnées XY du lieu de résidence dans le tableau des cyclistes
```{r jointure des coord XY dans le tableau des cyclistes}
VariablesTypoProfilCyclistes <- merge(VariablesTypoProfilCyclistes, CoordXY_Hogar, by = "id_hog")
```

## Import de la couches des UTAM (Unités Territoriales d'Analyse de la Mobilité)
```{r import UTAM}
UTAM <- st_read("EMU2019_UTAM_Bgta.gpkg")
```

## Création d'un semis de points (objet sf) à partir des coordonnées XY du lieu de résidence des cyclistes
```{r creation semis de points residence des cyclistes}
ResidCyclistes<- st_as_sf(VariablesTypoProfilCyclistes, coords=c("X_Hog_Alea","Y_Hog_Alea"), crs = st_crs(UTAM)$srid)
plot(st_geometry(ResidCyclistes), pch = ".")
```


## Préparation du jeu de données pour l'élaboration des cartes
```{r prepa donnees pour carto}
# étape nécessaire en vue de créer des cartes de densité lissées donnant à voir la concentration des lieux de résidence des cyclistes suivant leur profil
## pour créer une liste des profils de cyclistes, dans l'ordre
TypoProfilCyclistes <- VariablesTypoProfilCyclistes[order(VariablesTypoProfilCyclistes$profil, decreasing = FALSE), ]
ListProfils <- unique(TypoProfilCyclistes$profil)
```

## Série de cartes de densité montrant la concentration des lieux de résidence des cyclistes suivant leur profil
```{r carto, warning=FALSE, fig.height=13, fig.width=13}

# définition du nombre de classes
nclass <- 6

#création d'un ensemble de palettes de couleurs
pal1 <- hcl.colors(nclass, "YlOrRd", rev = TRUE)
pal2 <- hcl.colors(nclass, "Greens 3", rev = TRUE)
pal3 <- hcl.colors(nclass, "Reds 3", rev = TRUE)
pal4 <- hcl.colors(nclass, "Grays", rev = TRUE)
pal5 <- hcl.colors(nclass, "Oslo", rev = FALSE)
pal6 <- hcl.colors(nclass, "Red-Purple", rev = TRUE)
pal7 <- hcl.colors(nclass, "Inferno", rev = TRUE)
pal8 <- hcl.colors(nclass, "Reds", rev = TRUE)
pla9 <- hcl.colors(nclass, "Blues 3", rev = TRUE)
pal10 <- hcl.colors(nclass, "Purples 3", rev = TRUE)

# Et on les sauvegarde dans une liste
pal <- list(pal1, pal2, pal3, pal4, pal5, pal6, pal7, pal8, pla9, pal10)

# pour définir comme emprise pour le lissage, l'étendue des UTAM
Emprise <- as.owin(as(st_union(st_buffer(UTAM, 1000)), "Spatial"))

# Paramétrage des marges pour insérer le titre général et les titres de chaque carte
par(oma=c(3.5,0,3,0)+0.1, mar = c(0, 0.5, 1.2, 0.5))

plot.new()

# pour découper la fenêtre en 2 lignes et 3 colonnes (6 profils)
par(mfrow=c(2,3))

# boucle pour produire et cartographier une surface de densité par profil
for (i in ListProfils){
  
  # Récuperation des jeux de données par profil
  fichier <- TypoProfilCyclistes[which(TypoProfilCyclistes$profil == i),]
  
  # pour récupérer les coordonnées des lieux de résidence
  pts <- st_coordinates(st_geometry(st_as_sf(fichier, coords=c("X_Hog_Alea","Y_Hog_Alea"), crs = st_crs(UTAM)$srid)))
  
  # pour creer un objet ppp (format spatstat) et y integrer dedans l'emprise
  fichier.ppp <- ppp(pts[,1], pts[,2], window = Emprise)
  
  # pour définir la taille du rayon (en m.)
  rayon <- 1000
  
  # pour définir la taille du pixel (en m.)
  resol <- 100 # ici 100m x 100m = 1 ha.
  
  # pour calculer la surface de densité (rayon lissage : 1000 m et résolution spatiale de l'image : 100m x 100m = 1 ha)
  cartelissee <- density(fichier.ppp, sigma = rayon, kernel = "gaussian", eps = resol)
  
  # Conversion de la surface lissée au format raster
  cartelissee.raster <- raster(cartelissee)
  crs(cartelissee.raster) <- st_crs(UTAM)$srid # pour spécifier un SCR à l'objet raster
  
  # découpage du raster sur l'emprise des UTAM
  cartelissee.raster <- mask(cartelissee.raster, UTAM) 
  
  # passage des densités à des effectifs (multiplication des densités par la surface du cercle)
  values(cartelissee.raster) <- values(cartelissee.raster) * pi*rayon**2

  # Définition des seuils de classes
  bks <- seq(from = cellStats(cartelissee.raster, stat = min), 
			to = cellStats(cartelissee.raster, stat = max), 
			by = (cellStats(cartelissee.raster, stat = max) - cellStats(cartelissee.raster, stat = min)) / nclass)
  
  # reclassification de la surface lissée
  cartelissee.reclass <- cut(cartelissee.raster, breaks = bks, include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE)
  
  # vectorisation de la surface reclassée (calcul un peu long)
  cartelissee.vecteur <- as(rasterToPolygons(cartelissee.reclass, n=4, na.rm=TRUE, digits=12, dissolve=TRUE), "sf")
  
  # Tracer la carte
  plot(st_geometry(UTAM), border = "white", bg= "grey90")
  
  typoLayer(
    x = cartelissee.vecteur,
    var="layer",
    col = unlist(pal[as.numeric(i)]),
    lwd = 0.1,
    border = unlist(pal[as.numeric(i)]),
    legend.pos = "n",
    add = TRUE)
  
  legendChoro(
         pos = "bottomright",
         title.txt = "Nombre de ménages\navec cyclistes\ndans une rayon de 1 km.",
         title.cex = 0.6,
         breaks = bks, 
         values.rnd = 2,
         nodata = FALSE,
         col = unlist(pal[as.numeric(i)]),
         border = "white",
         horiz = FALSE
       )

  title(main =paste("Profil",i, sep="-"))
  
  mtext(text = paste0("n = ", nrow(fichier), " cyclistes"), 
      side = 3, line = -2, adj = 0.1, cex = 0.7)
  
}

barscale(
  lwd = 1.5,
  cex = 0.6,
  pos = "bottomleft",
  style = "pretty",
  unit = "m"
)

north(pos = "topright")

# Pour afficher le titre principal et la source
mtext("Lieux de résidence des cyclistes par profil dans l'AM de Bogotá", cex = 1.3, side=3,line=1,adj=0.5,outer=TRUE)
mtext("   Sources : EMU2019 - SDM - Rayon de lissage : 1000 m et résolution : 1 ha", side=1, line=1, adj=0, cex=0.6, outer=TRUE)
```

## Carte des lieux d’arrivée du premier trajet en vélo depuis le domicile
```{r import lieu destination}
destino <- st_read("ZAT_Destino_Saliendo_Casa.shp")
```

# création d'une liste de personne ayant au moins une destination connue
```{r creation liste des personnes ayant une destination}
listdestino <- as.character(destino$id_concat_)
```

# sélection des personnes ayant une destination connue
```{r selection des personnes ayant une destination}
TypoProfilCyclistes <- VariablesTypoProfilCyclistes[VariablesTypoProfilCyclistes$id_hog_pers %in% listdestino, ]
```

# jointure pour récuperer le profil sur le lieu de destination
```{r jointure pour recuperer profil sur lieu destination}
destino <- merge(destino, TypoProfilCyclistes[c(21:22)], by.x = "id_concat_", by.y = "id_hog_pers")
```

# Création de la deuxième série de carte par lieux de destination
```{r serie deuxieme carte, warning=FALSE, fig.height=13, fig.width=13}
# Paramétrage des marges pour insérer le titre général et les titres de chaque carte
par(oma=c(3.5,0,3,0)+0.1, mar = c(0, 0.5, 1.2, 0.5))

plot.new()

# pour découper la fenêtre en 2 lignes et 3 colonnes (6 profils)
par(mfrow=c(2,3))

# définition du nombre de classes
nclass <- 6

# boucle pour produire et cartographier une surface de densité par profil
for (i in ListProfils){
  
  # Récuperation des jeux de données par profil
  fichier <- destino[which(destino$profil == i),]
  
  # pour récupérer les coordonnées des lieux de résidence
  pts <- st_coordinates(st_geometry(fichier))
  
  # pour créer un objet ppp (format spatstat) et y intégrer dedans l'emprise
  fichier.ppp <- ppp(pts[,1], pts[,2], window = Emprise)
  
  # pour définir la taille du rayon (en m.)
  rayon <- 1000
  
  # pour définir la taille du pixel (en m.)
  resol <- 100 # ici 100m x 100m = 1 ha.
  
  # pour calculer la surface de densité (rayon lissage : 1000 m et resolution spatiale de l'image : 100m x 100m = 1 ha)
  cartelissee <- density(fichier.ppp, sigma = rayon, kernel = "gaussian", eps = resol)
  
  # Conversion de la surface lissée au format raster
  cartelissee.raster <- raster(cartelissee)
  crs(cartelissee.raster) <- st_crs(UTAM)$srid
  
  # découpage du raster sur l'emprise des UTAM
  cartelissee.raster <- mask(cartelissee.raster, UTAM) 
  
  # passage des densités à des effectifs (multiplication des densités par la surface du cercle)
  values(cartelissee.raster) <- values(cartelissee.raster) * pi*rayon**2

  # Définition des seuils de classes
  bks <- seq(from = cellStats(cartelissee.raster, stat = min), 
			to = cellStats(cartelissee.raster, stat = max), 
			by = (cellStats(cartelissee.raster, stat = max) - cellStats(cartelissee.raster, stat = min)) / nclass)
  
  # reclassification de la surface lissée
  cartelissee.reclass <- cut(cartelissee.raster, breaks = bks, include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE)
  
  # vectorisation de la surface reclassée (calcul un peu long)
  cartelissee.vecteur <- as(rasterToPolygons(cartelissee.reclass, n=4, na.rm=TRUE, digits=12, dissolve=TRUE), "sf")
  
  # Tracer la carte
  plot(st_geometry(UTAM), border = "white", bg= "grey90")
  
  typoLayer(
    x = cartelissee.vecteur,
    var="layer",
    col = unlist(pal[as.numeric(i)]),
    lwd = 0.1,
    border = unlist(pal[as.numeric(i)]),
    legend.pos = "n",
    add = TRUE)
  
  legendChoro(
         pos = "bottomright",
         title.txt = "Nombre de destinations\ndans un rayon de 1 km.",
         title.cex = 0.6,
         breaks = bks, 
         values.rnd = 2,
         nodata = FALSE,
         col = unlist(pal[as.numeric(i)]),
         border = "white",
         horiz = FALSE
       )

  title(main =paste("Profil",i, sep="-"))
  
  mtext(text = paste0("n = ", nrow(fichier), " cyclistes"), 
      side = 3, line = -2, adj = 0.1, cex = 0.7)
  
}

barscale(
  lwd = 1.5,
  cex = 0.6,
  pos = "bottomleft",
  style = "pretty",
  unit = "m"
)

north(pos = "topright")

# Pour afficher le titre principal et la source
mtext("Destination des premiers trajets à vélo depuis le domicile à Bogotá", cex = 1.3, side=3,line=1,adj=0.5,outer=TRUE)
mtext("   Sources : EMU2019 - SDM - Rayon de lissage : 1000 m et résolution : 1 ha", side=1, line=1, adj=0, cex=0.6, outer=TRUE)
```
